/**
 * GeneticAlgorithm.h
 *
 * By Sebastian Raaphorst, 2018.
 */

#pragma once

#include <omp.h>

#include <memory>
#include <vector>

#include "Candidate.h"
#include "Populator.h"
#include "PopulationSelector.h"
#include "RNG.h"

namespace vorpal::stochastic {
    /**
     * The fundamentals of running the genetic algorithm on the problem.
     * @tparam Fitness the measure of fitness for a candidate
     */
    template<typename T, typename Fitness=double>
    class GeneticAlgorithm final {
    public:
        using pointer_type = std::unique_ptr<T>;

        GeneticAlgorithm() = delete;

        struct Options {
            std::unique_ptr<Selector<T>> selector;
            std::unique_ptr<Populator<T>> populator;
            size_t population_size;
            double mutation_probability;
            double crossover_probability;
            size_t max_generations;
            Fitness fitness_success_threshold;
        };

        template<typename Opts>
        static pointer_type run(Opts&& options) {
            // Force population_size to be even for convenience.
            assert(options.population_size % 2 == 0);

            auto &gen = RNG::getGenerator();
            std::uniform_real_distribution<double> probabilityGenerator;

            std::vector<pointer_type> prevGeneration{options.population_size};

            // We want to store the best element seen to far, so keep the max generated by the population initializer.
            size_t max_init = 0;

            for (size_t i = 0; i < options.population_size; ++i) {
                prevGeneration[i] = std::move(options.populator->generate());
                if (prevGeneration[i]->fitness() > prevGeneration[max_init]->fitness()) {
                    max_init = i;
                }
            }

            // Now create the pointer and store.
            pointer_type best = options.populator->survive(prevGeneration[max_init]);

            // *** Begin a new generation ***
            for (size_t generation = 0; generation < options.max_generations - 1; ++generation) {
                std::cerr<< "Generation "<< generation<< '\n';
                // Create the candidates for the next generation.
                std::vector<pointer_type> nextGeneration{options.population_size};

                #pragma omp parallel for default(shared)
                for (size_t i = 0; i < options.population_size; i += 2) {
                    // Crossover if probability dictates.
                    if (probabilityGenerator(gen) < options.crossover_probability) {
                        const size_t p0Idx = options.selector->select(prevGeneration);
                        const auto &p0 = prevGeneration[p0Idx];
                        const size_t p1Idx = options.selector->select(prevGeneration);
                        const auto &p1 = prevGeneration[p1Idx];

                        auto [c0, c1] = options.populator->crossover(p0, p1);
                        nextGeneration[i] = (probabilityGenerator(gen) < options.mutation_probability) ?
                                std::move(options.populator->mutate(c0)) : std::move(c0);
                        nextGeneration[i+1] = (probabilityGenerator(gen) < options.mutation_probability) ?
                                            std::move(options.populator->mutate(c1)) : std::move(c1);
                    } else {
                        nextGeneration[i] = std::move(options.populator->survive(prevGeneration[i]));
                        nextGeneration[i+1] = std::move(options.populator->survive(prevGeneration[i+1]));
                    }
                }

                // Now get the fittest solution and see if it is fit enough.
                const auto &fittest = *std::max_element(std::cbegin(nextGeneration), std::cend(nextGeneration),
                        [](const auto &s1, const auto &s2) { return s1->fitness() < s2->fitness(); });
                if (fittest->fitness() > best->fitness())
                    best = std::move(options.populator->survive(fittest));
                if (best->fitness() >= options.fitness_success_threshold)
                    return std::move(best);

                // Copy the new generation to the old and give it a shuffle.
                // The shuffle is not likely necessary, but since we add parents in pairs, it will add some randomness.
                prevGeneration = std::move(nextGeneration);
                std::shuffle(std::begin(prevGeneration), std::end(prevGeneration), gen);
            }

            // Too many iterations: fail and return the best solution found thus far.
            return best;
        }
    };
}


