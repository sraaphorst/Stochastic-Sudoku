/**
 * GeneticAlgorithm.h
 *
 * By Sebastian Raaphorst, 2018.
 */

#pragma once

#include <omp.h>

#include <memory>
#include <vector>

#include "Candidate.h"
#include "Populator.h"
#include "PopulationSelector.h"
#include "RNG.h"

namespace vorpal::stochastic {
    /**
     * The fundamentals of running the genetic algorithm on the problem.
     * @tparam Fitness the measure of fitness for a candidate
     */
    template<typename T, typename Fitness=double>
    class GeneticAlgorithm final {
    public:
        using pointer_type = std::unique_ptr<T>;

        GeneticAlgorithm() = delete;

        struct Options {
            std::unique_ptr<Selector<T>> selector;
            std::unique_ptr<Populator<T>> populator;
            size_t population_size;
            double mutation_probability;
            double crossover_probability;
            size_t max_generations;
            Fitness fitness_success_threshold;
        };

        template<typename Opts>
        static pointer_type run(Opts&& options) {
            // Force population_size to be even for convenience.
            assert(options.population_size % 2 == 0);

            auto &gen = RNG::getGenerator();
            std::uniform_real_distribution<double> probabilityGenerator;

            std::vector<pointer_type> prevGeneration{};

            // We want to store the best element seen to far, so keep the max generated by the population initializer.
            size_t max_init = 0;

            //#pragma omp parallel for shared(prevGeneration, probabilityGenerator, gen)
            for (size_t i = 0; i < options.population_size; ++i) {
                prevGeneration.emplace_back(std::move(options.populator->generate()));
                if (prevGeneration[i]->fitness() > prevGeneration[max_init]->fitness())
                    max_init = i;
            }

            // Now create the pointer and store.
            pointer_type best = options.populator->survive(prevGeneration[max_init]);

            // *** Begin a new generation ***
            for (size_t generation = 0; generation < options.max_generations - 1; ++generation) {
                std::cerr<< "Generation "<< generation<< '\n';
                // Create the candidates for the next generation.
                std::vector<pointer_type> nextGeneration{};

                //#pragma omp parallel for shared(prevGeneration, probabilityGenerator, gen)
                for (int i = 0; i < options.population_size; i += 2) {
                    // Crossover if probability dictates.
                    if (probabilityGenerator(gen) < options.crossover_probability) {
                        const size_t p0Idx = options.selector->select(prevGeneration);
                        const auto &p0 = prevGeneration[p0Idx];
                        const size_t p1Idx = options.selector->select(prevGeneration);
                        const auto &p1 = prevGeneration[p1Idx];

                        auto [c0, c1] = options.populator->crossover(p0, p1);
                        if (probabilityGenerator(gen) < options.mutation_probability) {
                            auto m0 = options.populator->mutate(c0);
                            nextGeneration.emplace_back(std::move(m0));
                        } else {
                            nextGeneration.emplace_back(std::move(c0));
                        }
                        if (probabilityGenerator(gen) < options.mutation_probability) {
                            auto m1 = options.populator->mutate(c1);
                            nextGeneration.emplace_back(std::move(m1));
                        } else {
                            nextGeneration.emplace_back(std::move(c1));
                        }

                    } else {
                        auto d0 = options.populator->survive(prevGeneration[i]);
                        auto d1 = options.populator->survive(prevGeneration[i+1]);
                        nextGeneration.emplace_back(std::move(d0));
                        nextGeneration.emplace_back(std::move(d1));
                    }
                }

                // Now get the fittest solution and see if it is fit enough.
                const auto &fittest = *std::max_element(std::cbegin(nextGeneration), std::cend(nextGeneration),
                        [](const auto &s1, const auto &s2) { return s1->fitness() < s2->fitness(); });
                if (fittest->fitness() > best->fitness())
                    best = std::move(options.populator->survive(fittest));
                if (best->fitness() >= options.fitness_success_threshold)
                    return std::move(best);

                // Copy the new generation to the old.
                prevGeneration = std::move(nextGeneration);
            }

            // Too many iterations: fail.
            // TODO: removemove
            return std::move(best);
        }
    };
}


